<?xml version="1.0" encoding="UTF-8"?>
<html>
  <head>
    <style type="text/css">
    @media print {
      body { }
      p.img { text-align: center; page-break-inside: avoid }
      img.CC { display: inline }
    }
    @media screen {
      body { max-width: 800px; margin: auto }
      p.img { text-align: center }
      img.CC { display: inline }
    }
    p.date {
      font-size: smaller;
      margin: 0;
    }
    p.versionHistory {
      color: gray
    }
    p.versionHistory a {
      color: gray
    }
    p.ref {
      text-indent: -2em;
      padding-left: 2em;
    }
  </style>
    <!-- PDFjs code (more at the end of the document) -->
    <script src="https://mozilla.github.io/pdf.js/build/pdf.js"/>
  </head>
  <body>
    <h1>Importing General-Purpose Graphics in R</h1>
    <p>
      <span style="font-style: italic">by Paul Murrell</span>
      <a href="http://orcid.org">
        <img alt="" src="https://www.stat.auckland.ac.nz/~paul/ORCID/ORCiD.png" style="width: 16px; height: 16px; vertical-align: middle"/>
      </a>
      <span style="font-family: mono; font-size: small">
        <a href="http://orcid.org/0000-0002-3224-8858">http://orcid.org/0000-0002-3224-8858</a>
      </span>
    </p>
    <p class="date">
    Version 2:
    <rcode echo="FALSE" results="asis"><![CDATA[
cat(format(Sys.Date(), "%A %d %B %Y"))
    ]]></rcode>
  </p>
    <p class="date versionHistory">
    Version 1:  Wednesday 19 September 2018; original publication<br/>
    Version 2:  update pdf.js code (for displaying PDFs)
  </p>
    <rcode id="init" echo="FALSE" message="FALSE" results="hide"><![CDATA[
opts_chunk$set(comment=" ", tidy=FALSE)
options(width=100)
## For wonky desktop set up
options(bitmapType="cairo")
  ]]></rcode>
    <rcode echo="FALSE"><![CDATA[
    library(grid)
  ]]></rcode>
    <hr/>
    <p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img class="CC" alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a><br/><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
    <hr/>
    <p>
    This report discusses some problems that can arise when attempting to
    import PostScript images into R, when the PostScript image
    contains coordinate 
    transformations that skew the image.  There is a description of
    some new features in the 'grImport' package for R that allow these
    sorts of images to be imported into R successfully.
  </p>
    <div>
      <h2>Table of Contents:</h2>
      <ul style="list-style: none">
        <li>
          <a href="#intro">1. Introduction</a>
        </li>
        <li>
          <a href="#grimport">2. Changes to 'grImport'</a>
        </li>
        <li>
          <a href="#sources">3. Where do skewed lines come from?</a>
        </li>
        <li>
          <a href="#bonus">4. Importing dashed lines</a>
        </li>
        <li>
          <a href="#example">5. Integrating the imported image with an R plot</a>
        </li>
        <li>
          <a href="#discussion">6. Discussion</a>
        </li>
        <li>
          <a href="#summary">7. Summary</a>
        </li>
        <li>
          <a href="#requirements">8. Technical requirements</a>
        </li>
        <li>
          <a href="#Resources">9. Resources</a>
        </li>
        <li>
          <a href="#references">10. References</a>
        </li>
      </ul>
    </div>
    <h2>
      <a name="intro">1. Introduction</a>
    </h2>
    <p>
    One difference between general-purpose graphics languages like
    PostScript (<a href="#AdobeSystemsInc.:1999:PLR:297697">Adobe SystemsÂ Inc., 1999</a>) 
    or SVG (<a href="#Ferraiolo01scalablevector">Ferraiolo and ed., 2001</a>)
    and a statistical graphics system like the one
    in R (<a href="#R">R Core Team, 2018</a>) is how they work with coordinate transformations.
  </p>
    <p>
    In a general-purpose graphics language, there is usually a 
    "current transformation matrix" that transforms all
    graphical output.  For example, the following PostScript code,
    stored in a file called <code>simple.ps</code>,
    describes a simple thick line and a text label.
  </p>
    <rcode echo="FALSE"><![CDATA[
system("ps2eps -f simple.ps")
system("convert -density 100 simple.eps simple.png")
cat(readLines("simple.ps"), sep="\n")
  ]]></rcode>
    <img src="simple.png"/>
    <p>
    If we add a coordinate transformation at the start of that PostScript
    code, which inverts the y-axis and skews the image by scaling the x-axis
    by a factor of two, the transformation affects all of the output.
    In particular, both the text and the line have been horizontally 
    stretched and the text is now upside down.
    The code below is stored in a file called <code>transform.ps</code>.
  </p>
    <rcode echo="FALSE"><![CDATA[
system("ps2eps -f transform.ps")
system("convert -density 100 transform.eps transform.png")
cat(readLines("transform.ps"), sep="\n")
  ]]></rcode>
    <img src="transform.png"/>
    <p>
    This sort of coordinate transformation is often required in statistical 
    graphics to represent the scales on a plot.  In the plot
    below, the y-axis is inverted and the scaling factor on
    the x-axis is different than the scaling factor on the y-axis
    (both because of unequal scales and because of unequal 
    physical dimensions).  However, in a plot, we do not 
    want text to be written upside down just because the y-axis
    scale is inverted, nor do we want
    text to be distorted if the scales on the plot axes do not
    match.  Similarly, when we draw a line through data, we do
    not want the width of the line to be distorted by
    differences between the scales on the plot axes.
  </p>
    <rcode fig.height="5"><![CDATA[
plot(c(1, 20), c(1, 10), type="l", lwd=20, ylim=c(10, 1), lend="butt")
text(15, 2, "Hello", cex=4, family="Times")
  ]]></rcode>
    <p>
    This means that, in R graphics, although features like 
    the location of data symbols and the location of text labels
    on a plot must obey the coordinate system of the scales on the axes,
    features like the size of text and the thickness of lines completely
    ignore the plot coordinate system.
  </p>
    <p>
    This difference in the treatment of coordinate systems creates
    a problem when it comes to importing general-purpose 
    graphical images, such as
    PostScript images, into R.
    The following code uses version 0.9-1 of the 'grImport' package
    (made available as the package 'grImportOLD' for this report)
    to import the <code>transform.ps</code> PostScript image into
    R.  In the resulting image,  the line is not
    distorted in R like it was in the original PostScript image,
    This reflects the fact that R graphics ignores 
    coordinate transformations when calculating the width (or shape)
    of the line.  (The fact that the text is actually drawn
    correctly is something that we will come back to later.)
  </p>
    <rcode id="badtrans" eval="FALSE"><![CDATA[
library(grImportOLD)
grImportOLD::PostScriptTrace("transform.ps", "transform-0.9-1.xml")
badTransform <- grImportOLD::readPicture("transform-0.9-1.xml")
grImportOLD::grid.picture(badTransform)
  ]]></rcode>
    <rcode echo="FALSE" results="hide" message="FALSE" fig.keep="FALSE"><![CDATA[
pdf("badtransform.pdf", width=3, height=2)
<<badtrans>>
dev.off()
  ]]></rcode>
    <canvas id="badtransform" class="pdf"/>
    <p>
    This report describes an update of the 'grImport' package
    that solves this problem, so that PostScript images that contain
    coordinate transformations like the one in 
    <code>transform.ps</code> 
    can be rendered faithfully in R.
  </p>
    <h2>
      <a name="grimport">2. Changes to 'grImport'</a>
    </h2>
    <h3>The strokepath operator</h3>
    <p>
    The changes to 'grImport' in version 0.9-2 are based on 
    the <code>strokepath</code> operator in PostScript.
    This operator takes a path (a collection of lines and curves) and, 
    instead of stroking it 
    (drawing a line along the path), calculates a new path that
    describes the outline of the area that would have been drawn 
    by stroking the original path.
  </p>
    <p>
    The following PostScript code illustrates this idea.
    This code begins by describing exactly the same path
    as in <code>transform.ps</code> (a thick straight line between
    two points, distorted by a scaling transformation).  
    However, just after the
    <code>10 setlinewidth</code> operation, this code calls
    <code>strokepath</code> and then <code>1 setlinewidth</code>.
    This means that the subsequent <code>stroke</code>, 
    instead of drawing a thick straight line between two points,
    draws the outline of that thick straight line.
  </p>
    <rcode echo="FALSE"><![CDATA[
system("ps2eps -f strokepath.ps")
system("convert -density 100 strokepath.eps strokepath.png")
cat(readLines("strokepath.ps"), sep="\n")
  ]]></rcode>
    <img src="strokepath.png"/>
    <p>
    To reproduce the original distorted straight line in R, 
    instead of importing the original thick straight line between two points,
    we can import the outline of that thick straight line and fill
    in the outline.  In other words, we turn the original stroke operation
    of a  straight line into
    a fill operation of the outline of the straight line.
    This works because, although R graphics cannot draw a skewed thick line,
    it is capable of filling in an outline.
  </p>
    <h3>Adding strokepath to PostScriptTrace</h3>
    <p>
    The above shows how it is possible, by inserting a
    <code>strokepath</code> operation,
    to convert an original PostScript image containing a stroke that R 
    cannot draw
    into a PostScript image containing a fill that R can draw.
    However, 
    there remains the problem of how to add that <code>strokepath</code>
    conversion to an image that we want to import into R.
  </p>
    <p>
    The answer to that problem goes to the heart of how the 'grImport'
    package works.  The first step in importing a PostScript image
    into R is a call to the <code>PostScriptTrace</code> function,
    which converts a PostScript file into an XML file containing
    graphics operations that R can draw.  The 
    <code>PostScriptTrace</code> function works by running its own
    PostScript code to process the PostScript file that we want to
    import.  The small R function below, <code>pscode</code>,
    gives some idea of how that works.
  </p>
    <p>
    This function just generates some
    PostScript code, given the name of a PostScript file.  
  </p>
    <rcode><![CDATA[
pscode <- function(psimage) {
    c("/stroke {",
      "  strokepath",
      "  fill",
      "} def",
      paste0("(", psimage, ") run"))
}
  ]]></rcode>
    <p>
    For example, if we are interested in the <code>simple.ps</code> 
    PostScript image, we generate the following PostScript code.
  </p>
    <rcode><![CDATA[
cat(pscode("simple.ps"), sep="\n")
  ]]></rcode>
    <p>
    The last line of the PostScript code,
    <code>(simple.ps) run</code>, will execute the PostScript code
    in the file <code>simple.ps</code>.  In other words, the PostScript
    code we have generated is designed to run the PostScript code
    in the original image.  The code before that defines a PostScript operation
    called <code>stroke</code>.  When the <code>stroke</code> operation
    is encountered, this definition will be run, which will call the
    <code>strokepath</code> operator and then the <code>fill</code> operator.
  </p>
    <p>
    The definition of the <code>stroke</code> operator is significant
    because that overrides the pre-existing <code>stroke</code> 
    operator.  This means that, when we run the PostScript code
    in <code>simple.ps</code>, when we hit a <code>stroke</code> operation,
    instead of stroking a path, we will run
    <code>strokepath</code> and <code>fill</code> instead.
    This is how we  can inject a
    <code>strokepath</code> operation into an existing PostScript
    image;  by hijacking the standard PostScript <code>stroke</code> operator
    and replacing
    it with our own definition.
  </p>
    <h3>Determining when to use strokepath</h3>
    <p>
    In reality, we do not want to replace a stroke with
    a fill all the time.   We only want to do this when the line has
    been skewed by unequal scaling factors.   
    The R function below, <code>scalecode</code>,
    demonstrates how we can do this sort of
    check, using the same idea as above.  We redefine the 
    <code>stroke</code> operator to look at the current PostScript
    transformation matrix (using the <code>currentmatrix</code>
    operator) and calculate the amount of x-scaling and y-scaling
    in force when the <code>stroke</code> operator is called.
  </p>
    <rcode><![CDATA[
scalecode <- function(psimage) {
    c("/str 50 string def",
      "/showscale {",
      "  matrix currentmatrix aload pop pop pop",
      "  dup mul exch dup mul add sqrt 3 1 roll",
      "  dup mul exch dup mul add sqrt",
      "  (xscale=) print dup str cvs print",
      "  (, yscale=) print exch dup str cvs print",
      "} def",
      "/stroke {",
      "  showscale",
      "} def",
      paste0("(", psimage, ") run"))
}
  ]]></rcode>
    <p>
    The function below, <code>showscale</code>,
    shows how we can run ghostscript (<a href="#mertz1997ghostscript">Mertz, 1997</a>) from R
    to run the PostScript code that the <code>scalecode</code> function
    generates.
  </p>
    <rcode><![CDATA[
showscale <- function(psimage) {
    ps <- scalecode(psimage)
    psfile <- tempfile()
    writeLines(ps, psfile)
    cat(system(paste0("gs -dNOPAUSE -dBATCH -q ",
                      "-sDEVICE=ps2write -sOutputFile=tmp.ps ",
                      psfile), intern=TRUE), "\n")
}
  ]]></rcode>
    <p>
    The result of this function for the <code>simple.ps</code>
    PostScript image (without
    scaling) is shown below.
  </p>
    <rcode><![CDATA[
showscale("simple.ps")
  ]]></rcode>
    <p>
    The result for the PostScript image <code>transform.ps</code>
    shows that the x-scaling and y-scaling are unequal.  In the
    'grImport' function <code>PostScriptTrace</code>, this
    case is detected and a <code>strokepath</code> plus <code>fill</code>
    is used instead of the original <code>stroke</code>.
  </p>
    <rcode><![CDATA[
showscale("transform.ps")
  ]]></rcode>
    <p>
    The code below shows that the new version of 'grImport'
    correctly renders the PostScript image <code>transform.ps</code> in R
    (because it fills the outline of the line, rather than stroking the line).
  </p>
    <rcode id="goodtrans" eval="FALSE"><![CDATA[
library(grImport)
PostScriptTrace("transform.ps", "transform-0.9-2.xml")
goodTransform <- readPicture("transform-0.9-2.xml")
grid.picture(goodTransform)
  ]]></rcode>
    <rcode echo="FALSE" results="hide" message="FALSE" fig.keep="FALSE"><![CDATA[
pdf("goodtransform.pdf", width=3, height=2)
<<goodtrans>>
dev.off()
  ]]></rcode>
    <canvas id="goodtransform" class="pdf"/>
    <h2>
      <a name="sources">3. Where do skewed lines come from?</a>
    </h2>
    <p>
    The simple PostScript examples used so far have been extremely
    basic, just to make the coordinate transformations clear.
    In practice, we are unlikely to be importing a PostScript
    image that we have generated by hand.  The reason for wanting to
    import an external image into R is because we have used 
    a different graphics system to generate the image.
    And the reason for using a different graphics system is 
    because other graphics systems
    are much better than R at generating certain sorts of images.
    For example, PGF/TikZ (<a href="#tantau:2013">Tantau, 2013</a>) 
    is better than R for drawing diagrams.
  </p>
    <p>
    This section briefly shows an example of a simple shape generated
    using MetaPost (<a href="#metapost">Hobby, 1998</a>).  
    The point of this example is to show
    a graphics system where it is straightforward to describe 
    a line with a skewed transformation.
  </p>
    <p>
    The MetaPost code below describes a loop shape, by describing 
    a set of points and asking MetaPost to draw a curve through the
    points.  
  </p>
    <rcode echo="FALSE"><![CDATA[
system("mpost loop.mp")
system("convert -density 100 loop.ps loop.png")
cat(readLines("loop.mp"), sep="\n")
  ]]></rcode>
    <img src="loop.png"/>
    <p>
    The most 
    important line of code is the line starting <code>pickup pencircle</code>.
    This line describes the "pen" that is used to draw the curve and
    it says that the pen is taller than it is wide and that the pen
    is rotated anticlockwise.  The shape of this pen is shown below
    (at five times its proper size).
  </p>
    <rcode echo="FALSE"><![CDATA[
system("mpost pen.mp")
system("convert -density 100 pen.ps pen.png")
  ]]></rcode>
    <img src="pen.png"/>
    <p>
    This ability to draw lines with a skewed pen makes it very easy
    to draw skewed lines in a MetaPost image.
  </p>
    <p>
    If we try to import this image with version 0.9-1 of 'grImport',
    we get a poor result because R is stroking the line with
    a fixed width (because that is the best that R can do).
  </p>
    <rcode id="badC" eval="FALSE"><![CDATA[
grImportOLD::PostScriptTrace("loop.ps", "loop-0.9-1.xml")
badLetterC <- grImportOLD::readPicture("loop-0.9-1.xml")
grImportOLD::grid.picture(badLetterC)
  ]]></rcode>
    <rcode echo="FALSE" results="hide" message="FALSE" fig.keep="FALSE"><![CDATA[
pdf("badloop.pdf", width=3, height=2)
<<badC>>
dev.off()
  ]]></rcode>
    <canvas id="badloop" class="pdf"/>
    <p>
    However, with the new version of 'grImport', we can import the
    MetaPost image correctly (because we detect that the line has been
    skewed and fill the outline of the stroke rather than trying to
    stroke it).
  </p>
    <rcode id="goodC" eval="FALSE"><![CDATA[
PostScriptTrace("loop.ps", "loop-0.9-2.xml")
goodLetterC <- readPicture("loop-0.9-2.xml")
grid.picture(goodLetterC)
  ]]></rcode>
    <rcode echo="FALSE" results="hide" message="FALSE" fig.keep="FALSE"><![CDATA[
pdf("goodloop.pdf", width=3, height=2)
<<goodC>>
dev.off()
  ]]></rcode>
    <canvas id="goodloop" class="pdf"/>
    <h2>
      <a name="bonus">4. Importing dashed lines</a>
    </h2>
    <p>
    The test within the <code>PostScriptTrace</code> function that
    determines whether the x-scaling and y-scaling within a
    PostScript file are the same is an example of a test for equality
    between two floating point values.  And testing
    for equality between floating point values is a mistake that people should
    make at most once in their life.
  </p>
    <rcode><![CDATA[
0.1 == 0.3 - 0.2
  ]]></rcode>
    <p>
    As a consequence, the actual test that <code>PostScriptTrace</code> 
    performs is whether the absolute difference between the 
    x-scaling and the y-scaling is very small.
    The amount "very small" defaults to 0.1, but <code>PostScriptTrace</code>
    provides a <code>scaleEPS</code> argument so that the user can
    control what "very small" means.
  </p>
    <p>
    This turns out to be useful in a slightly different problem that
    arises when importing PostScript images into R:  dashed lines.
  </p>
    <p>
    In PostScript, the <code>setdash</code> operator is used to set
    the dash pattern for stroking a path.  The code below shows an example,
    where the dash pattern is 3 units on then 3 units off, with an
    offset of 1.5 (so we start half-way through the first "on").
  </p>
    <rcode echo="FALSE"><![CDATA[
system("ps2eps -f dash.ps")
system("convert -density 100 dash.eps dash.png")
cat(readLines("dash.ps"), sep="\n")
  ]]></rcode>
    <img src="dash.png"/>
    <p>
    The line width in this example is set to 10, so the dashes are shorter 
    than the line is wide and, unfortunately, this is something that
    R graphics cannot emulate.
    In R graphics, the <code>lty</code> graphics parameter can be specified
    as an even number of (up to eight) on-off values, but the smallest 
    value is 1, which corresponds to the width of the line.
    Furthermore, R graphics has no concept of 
    a "dash offset".
  </p>
    <p>
    This means that 'grImport' does a poor job of 
    importing the PostScript dashed line from above. 
  </p>
    <rcode id="baddsh" eval="FALSE"><![CDATA[
PostScriptTrace("dash.ps", "dash-bad.xml")
badDash <- readPicture("dash-bad.xml")
grid.picture(badDash)
  ]]></rcode>
    <rcode echo="FALSE" results="hide" message="FALSE" fig.keep="FALSE"><![CDATA[
pdf("baddash.pdf", width=3, height=2)
<<baddsh>>
dev.off()
  ]]></rcode>
    <canvas id="baddash" class="pdf"/>
    <p>
    However, because we can select our own value of <code>scaleEPS</code>,
    and whenever the absolute difference between x-scaling and 
    y-scaling is greater than <code>scaleEPS</code> we convert a
    PostScript <code>stroke</code> to a <code>fill</code>,
    if we set <code>scaleEPS</code> to be negative, <em>every</em>
    <code>stroke</code> will be converted to a  <code>fill</code>,
    and 'grImport' will reproduce the dashed line perfectly
    (as shown below).
  </p>
    <rcode id="gooddsh" eval="FALSE"><![CDATA[
library(grImport)
PostScriptTrace("dash.ps", "dash-good.xml", scaleEPS=-1)
goodDash <- readPicture("dash-good.xml")
grid.picture(goodDash)
  ]]></rcode>
    <rcode echo="FALSE" results="hide" message="FALSE" fig.keep="FALSE"><![CDATA[
pdf("gooddash.pdf", width=3, height=2)
<<gooddsh>>
dev.off()
  ]]></rcode>
    <canvas id="gooddash" class="pdf"/>
    <h2>
      <a name="example">5. Integrating the imported image with an R plot</a>
    </h2>
    <p>
    All previous examples in this report
    have only demonstrated that it is possible
    to replicate an external PostScript image within R.
    This section describes a slightly more realistic scenario
    that incoporates an imported 
    PostScript image within an R plot.
  </p>
    <p>
    The following code produces a 'lattice' (<a href="#pkg:lattice">Sarkar, 2008</a>) 
    plot with a small
    customisation:  there is a text label and a line (with an arrow)
    from the label to a point in the plot.
  </p>
    <rcode><![CDATA[
library(lattice)
library(grid)
rx4 <- mtcars[1, ]
xyplot(mpg ~ disp, mtcars, pch=16,
       panel=function(...) {
           grid.text(rownames(rx4), 400, 27, just="left",
                     default.units="native")
           grid.segments(400, 27, rx4$disp, rx4$mpg,
                         default.units="native",
                         arrow=arrow())
           panel.xyplot(...)
       })           
  ]]></rcode>
    <p>
    The MetaPost system, with its 'mparrows' module, has a much wider
    range of line styles and arrowheads than R (even taking into 
    account packages like 'shape' (<a href="#pkg:shape">Soetaert, 2018</a>) 
    and 'DiagrammeR' (<a href="#pkg:diagrammer">Iannone, 2018</a>)).
    Rather than attempt to rewrite facilities similar to MetaPost's 
    within R, we can just make use of MetaPost to draw a line
    and then import it into R.
  </p>
    <p>
    The following code defines a function that generates, imports,
    and draws a MetaPost line between two points.
    It first generates MetaPost code to draw a line, based on a
    start and end point and start and end angles.
    This code also draws a rectangle of a specified width and height.
    The MetaPost code is run to produce a PostScript file and the
    PostScript file is imported into R.  Within R, the rectangle
    is removed (that was just to scale the image correctly) and 
    then the remaining line (plus arrow) is drawn.
  </p>
    <!-- NOTE that the double-dash syntax for straight lines between
       points in MetaPost cannot be used within XML comments, so
       the code in the function below splits each double-dash
       into two individual dashes and paste0()s them together -->
    <rcode><![CDATA[
mpLine <- function(x1, y1, x2, y2, angle, w, h) {
    mpcode <- c("prologues := 3;",
                'outputtemplate := "%j.ps";',
                "input mparrows;",
                "setarrows(barbed);",
                "barbedarrowindent := .6;",
                "ahlength := 5mm;",
                "beginfig(1);",
                paste0("draw (0,0)-", "-(",
                       w, "cm,0)-", "-(",
                       w, "cm,", h, "cm)-", "-(",
                       "0,", h, "cm)-", "-cycle;"),
                paste0("z0 = (", x1, "cm,", y1, "cm);"),
                paste0("z1 = (", x2, "cm,", y2, "cm);"),
                paste0("drawarrow z0{dir ", angle, "}..z1{dir ", angle, "};"),
                paste0("pickup pencircle xscaled 5pt yscaled .5pt rotated ",
                       angle, ";"),
                paste0("draw z0{dir ", angle, "}..z1{dir ", angle, "};"),
                "endfig;",
                "end")
    mpfile <- "line.mp"
    psfile <- "line.ps"
    xmlfile <- "line.xml"
    writeLines(mpcode, mpfile)
    system(paste0("mpost ", mpfile))
    PostScriptTrace(psfile, xmlfile)
    pic <- readPicture(xmlfile)
    line <- pic[-1]
    line@summary@xscale <- pic@summary@xscale
    line@summary@yscale <- pic@summary@yscale
    grid.picture(line, exp=0)
}    
  ]]></rcode>
    <p>
    The image below shows an example of the MetaPost 
    image that this function creates (complete with its border
    rectangle).
  </p>
    <rcode echo="FALSE" results="hide"><![CDATA[
system("ps2eps -f line.ps")
system("convert -density 100 line.eps line.png")
cat(readLines("line.ps"), sep="\n")
  ]]></rcode>
    <img src="line.png"/>
    <p>
    The next code makes use of that function to add a MetaPost line
    to the 'lattice' plot.  Some calculations are required to 
    express the line start point and end point, and the overall 
    size of the MetaPost image, in terms of centimetres
    (all within the 'grid' viewport that corresponds to the
    'lattice' plot panel). 
  </p>
    <rcode dev="svg"><![CDATA[
xyplot(mpg ~ disp, mtcars,
       panel=function(...) {
           panel.xyplot(...)
           textLeft <- unit(400, "native")
           textY <- unit(27, "native")
           grid.text(rownames(rx4), textLeft, textY, just="left")
           textLeftCM <- convertX(textLeft - unit(1, "mm"), "cm",
                                  valueOnly=TRUE)
           textYCM <- convertY(textY, "cm", valueOnly=TRUE)
           pointRightCM <- convertX(unit(mtcars$disp[1], "native") +
                                    unit(2, "mm"), "cm",
                                    valueOnly=TRUE)
           pointYCM <- convertY(unit(mtcars$mpg[1], "native") -
                                unit(2, "mm"), "cm",
                                valueOnly=TRUE)
           panelWidthCM <- convertWidth(unit(1, "npc"), "cm",
                                        valueOnly=TRUE)
           panelHeightCM <- convertHeight(unit(1, "npc"), "cm",
                                          valueOnly=TRUE)
           mpLine(textLeftCM, textYCM, pointRightCM, pointYCM,
                  135, panelWidthCM, panelHeightCM)
       })
  ]]></rcode>
    <h2>
      <a name="discussion">6. Discussion</a>
    </h2>
    <h3>Why not convert everything to a path?</h3>
    <p>
    The 'grImport' package successfully imports skewed lines by
    converting them to filled paths, but this conversion is only
    performed where necessary.  An alternative would be to convert
    all shapes into paths (similar to what happens in SVG output
    with Cairo graphics; <a href="#cairo">Packard etÂ al., 2018</a>), but that is not done 
    in 'grImport' because
    rendering of paths is not as good as rendering of the original
    shapes in some cases.  For example, rendering a very thin line
    as a path can lead to either a too heavy line or no line at all
    because on some graphics devices at least, a line will be 
    anti-aliased, but a path will not.  The code
    below draws a series of 
    thin, horizontal filled rectangles (on the left) and a series of 
    line segments (on the right), with the "width" of the result slowly
    decreasing.  The "widths" of the filled rectangles decrease in quantum
    steps (and the final one disappears), while the 
    line segments decrease more smoothly due to antialiasing.
  </p>
    <rcode fig.width="1" fig.height="1"><![CDATA[
grid.rect(x=.2, width=.3, y=1:5/6, height=unit(1:5, "pt"), 
          gp=gpar(col=NA, fill="black"))
grid.segments(.6, 1:5/6, .9, 1:5/6, 
              gp=gpar(lwd=1:5, lineend="butt"))
  ]]></rcode>
    <p>
    Similarly, text that is
    rendered as filled paths rather than using proper font rendering
    can produce a worse result because font
    rendering uses techniques such as "hinting" to produce a good result
    and filling a path does not use these techniques.  
  </p>
    <p>
    On the other hand, importing text is tricky because it is not 
    necessarily easy or possible 
    to find the font that was used to draw the original
    image.  The reason
    the upside-down text was imported correctly right back at the 
    beginning of this report is because, by default, 'grImport'
    converts text in a PostScript image to a filled path. 
  </p>
    <h3>Importing images versus including images</h3>
    <p>
    Being able to <em>import</em> images into R is different from being
    able to <em>include</em>
    an image.  Importing an image means converting it into the
    language and data structures of the parent system.
    By contrast, including an image means keeping the image
    as a single opaque object (e.g., including a PostScript image
    within a LaTeX document).  
    Importing an image is useful because it exposes the image to the
    facilities of the container language.  For example, having imported
    an image into R, we
    can use R subsetting to extract just some portion of the original image
    as we did to remove the rectangle border from a MetaPost image 
    in the Section <a href="#example">Integrating the imported image with an R plot</a>).
  </p>
    <h3>Loss of information</h3>
    <p>
    When we are importing an image between
    higher-level languages, like MetaPost or R, going through
    a lower-level intermediary, like PostScript, means that we lose
    some of the information about the original image when we
    attempt to move between higher-level languages.  
  </p>
    <p>
    This report has described one situation where the higher-level 
    system (R in this case) loses information when importing the lower-level
    intermediary (PostScript); 
    a skewed stroke in MetaPost, which remains a skewed stroke in PostScript,
    becomes a filled path in R.
  </p>
    <p>
    Loss of information can also occur in the transition from
    higher-level language to lower-level intermediary.
    For example, in MetaPost
    it is possible to describe a line that
    is drawn with a pen that varies along the length of the line
    (essentially producing a variable-width line).  This cannot be
    converted directly to a line stroke in PostScript, 
    so the PostScript that is generated
    from MetaPost produces a filled path, rather than a line.
    <!-- https://tex.stackexchange.com/questions/341495/change-rotation-of-metapost-pens-dynamically-while-drawing -->
    The MetaPost code below draws a curve between three
    points, with a different pen width and angle specified at each point, but
    this produces PostScript that is a filled path rather than a stroked line
    (as can be seen in the final line of the PostScript code that
    is shown below the image).
  </p>
    <rcode echo="FALSE"><![CDATA[
system("mpost vwline.mp")
system("convert -density 100 vwline.ps vwline.png")
cat(readLines("vwline.mp"), sep="\n")
  ]]></rcode>
    <img src="vwline.png"/>
    <rcode echo="FALSE"><![CDATA[
cat(readLines("vwline.ps"), sep="\n")
  ]]></rcode>
    <p>
    This is also how the 'vwline' package (<a href="#vwline-pkg">Murrell, 2017</a>) for
    drawing variable-width lines
    in R works; it
    generates paths to fill rather than lines to stroke.
  </p>
    <!--
  <p>
    This loss of information means that the original MetaPost line
    description ends up as a filled path when the line is imported
    into R and this can limit the actions that are possible with the
    imported image.  For example, the following MetaPost image 
    contains two lines (in terms of MetaPost concepts),
    but when it is exported to PostScript, 
    one of the MetaPost lines becomes a filled path in PostScript.
  </p>
  <rcode echo="FALSE"><![CDATA[
system("mpost linesandpaths.mp")
system("convert -density 100 linesandpaths.ps linesandpaths.png")
cat(readLines("linesandpaths.mp"), sep="\n")
  ]]></rcode>
  <img src="linesandpaths.png"/>
  <p>
    If we import this image into R and change all "line" grobs to
    red, only one of the lines changes (because only one MetaPost
    line is a PostScript stroke; the other MetaPost line is a 
    PostScript path).
  </p>
  <rcode fig.width="2" fig.height="2"><![CDATA[
PostScriptTrace("linesandpaths.ps", "linesandpaths.xml")
x <- readPicture("linesandpaths.xml")
grid.picture(x, exp=.2)
grid.force()
grid.edit("line", grep=TRUE, global=TRUE, gp=gpar(col="red"))
  ]]></rcode>
  -->
    <p>
    Where possible, it is therefore better to be able to convert more directly 
    between higher-level languages.  This is what, for example,
    the 'tikzDevice' (<a href="#pkg:tikz">Sharpsteen and Bracken, 2018</a>) 
    does by converting R graphics output into PGF/TikZ graphics.
    Another example, is the 
    conversion that the 'gridGraphics' package (<a href="#pkg:gridgraphics">Murrell and Wen, 2018</a>)
    performs between the 'graphics' system and the 'grid' system
    (entirely within R).
  </p>
    <h3>The special nature of PostScript</h3>
    <p>
    Importing PostScript is a special case because the PostScript
    language is Turing-complete, which means that we can 
    write complex programs in PostScript.  The 'grImport' package
    takes advantage of this by writing its own PostScript
    code to  process PostScript images.
  </p>
    <p>
    Although a more modern graphics language like SVG has more 
    advanced graphics features than PostScript (e.g., filters,
    semi-transparency, and animation), there is no facility in the
    SVG language itself that can assist with, for example,
    converting an SVG line into an SVG path.
  </p>
    <p>
    This means that, although the 'grImport2' package 
    (<a href="#pkg:grimport2">Potter, 2018</a>), which can import
    (a subset of) SVG images into R, is useful for importing images
    that have features that cannot appear in a PostScript image,
    we cannot import SVG images that contain skewed lines using
    'grImport2' because the transformation from stroked line
    to filled path that 'grImport' can achieve with PostScript images
    is not available to 'grImport2'.
  </p>
    <h3>Having your cake and eating it</h3>
    <p>
    The original problem with importing skewed lines into R 
    is based on the fact that R graphics
    does not allow coordinate transformations to impact on
    text and line styles.  However, although this restriction within R
    graphics is justified, it is not absolutely necessary.
    The PGF/TikZ graphics system has identified the same problem,
    but has a more sophisticated solution, which involves
    maintaining more than
    one set of coordinate transformations.  In PGF/TikZ, there
    is a "canvas" transformation that acts like PostScript,
    affecting all graphics (including skewed lines if scaling
    transformations are unequal), and a "coordinate" transformation
    that only affects locations, like in R graphics.  Managing the
    two transformations coherently requires care, but this does
    allow a greater expressiveness in PGF/TikZ graphics.
  </p>
    <p>
    Another example of a sophisticated solution to this problem
    is the SVG 2 Candidate Recommendation (<a href="#Schulze:18:SVG">Schulze etÂ al., 2018</a>),
    which includes a 'vector-effect' attribute.  This allows
    different parts of the SVG transformation matrix to be ignored.
    <!-- https://www.w3.org/TR/2018/CR-SVG2-20180807/coords.html#VectorEffects -->
    For example, it is possible to specify that part of an SVG image will
    ignore the current rotation and/or scaling within an image.
  </p>
    <h2>
      <a name="summary">7. Summary</a>
    </h2>
    <p>
    R graphics, unlike general-purpose graphics languages such as PostScript,
    only applies coordinate system transformations selectively.
    This makes it difficult to import some PostScript images.
    Version 0.9-2 of the 'grImport' package at least partially solves
    this problem by converting lines to filled paths when the coordinate
    transformation involves unequal scaling in the x- and y-dimensions.
    As a bonus, this also provides a way to
    successfully import PostScript images that contain stroked paths
    with a fancy dash pattern.  One example application of this new
    facility is the import into R of images that were produced by the 
    MetaPost language.
  </p>
    <p>
  </p>
    <h2>
      <a name="requirements">8. Technical requirements</a>
    </h2>
    <p>
    The examples and discussion in this document relate to <a href="grImport_0.9-2.tar.gz">version
    0.9-2</a> of the 'grImport' package.
  </p>
    <p>
    This report was generated within a Docker container
    (see <a href="#Resources">Resources</a> section below).
  </p>
    <h2>
      <a name="Resources">9. Resources</a>
    </h2>
    <ul>
      <li>
      The <a href="skew.cml">raw source file</a> for this
      report, a <a href="skew.xml">valid XML</a>
      transformation of the source file, a <a href="skew.Rhtml">'knitr' document</a> generated from
      the XML file, 
      two <a href="toc.R">R</a> <a href="bib.R">files</a> and
      the <a href="skew.bib">bibtex file</a>
      that are used to generate the table of contents and reference sections,
      two <a href="common.xsl">XSL</a> <a href="knitr.xsl">files</a> and an 
      <a href="knit.R">R file</a> that are used to transform the XML to
      the 'knitr' document, and a <a href="Makefile">Makefile</a> that
      contains code for the other transformations and coordinates
      everything.  
      These materials are also available
      on <a href="https://github.com/pmur002/skew-report/releases/tag/v2">github</a>.
    </li>
      <li><a href="grImportOLD_0.9-1t.tar.gz">Version 0.9-1</a>
      of 'grImport' packaged as 'grImportOLD'.
    </li>
      <li>
      This report was generated within a 
      <a href="https://www.docker.com/">Docker</a> container.
      The Docker command to build the report is included in the Makefile above.
      The Docker image for the container is available from
      <a href="https://hub.docker.com/r/pmur002/skew/">Docker Hub</a>;
      alternatively, the image can be rebuilt from its 
      <a href="Dockerfile">Dockerfile</a>.
    </li>
    </ul>
    <h2>How to cite this document</h2>
    <p>
    Murrell, P. (2018). "Importing General-Purpose Graphics in R" 
    Technical Report 2018-09, Department of Statistics, The University of Auckland. 
    [ <a href="how-to-cite.bib">bib</a> ] 
  </p>
    <h2>
      <a name="references">10. References</a>
    </h2>
    <dl><dt>
[<a name="AdobeSystemsInc.:1999:PLR:297697">Adobe SystemsÂ Inc., 1999</a>]
</dt>
<dd>
Adobe SystemsÂ Inc., C. (1999).
 <em>PostScript Language Reference (3rd Ed.)</em>.
 Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA.
[Â <a href="skew-bib_bib.html#AdobeSystemsInc.:1999:PLR:297697">bib</a>Â ]

</dd>


<dt>
[<a name="Ferraiolo01scalablevector">Ferraiolo and ed., 2001</a>]
</dt>
<dd>
Ferraiolo, J. and ed. (2001).
 Scalable Vector Graphics (SVG) 1.0 specification.
[Â <a href="skew-bib_bib.html#Ferraiolo01scalablevector">bib</a>Â ]

</dd>


<dt>
[<a name="metapost">Hobby, 1998</a>]
</dt>
<dd>
Hobby, J. (1998).
 <em>A User's Manual for MetaPost</em>.
[Â <a href="skew-bib_bib.html#metapost">bib</a>Â ]

</dd>


<dt>
[<a name="mplib">Hoekwater and Hagen, 2007</a>]
</dt>
<dd>
Hoekwater, T. and Hagen, H. (2007).
 Mplib: MetaPost as a reusable component.
 <em>TUGboat</em>, 28(3).
[Â <a href="skew-bib_bib.html#mplib">bib</a>Â ]

</dd>


<dt>
[<a name="pkg:diagrammer">Iannone, 2018</a>]
</dt>
<dd>
Iannone, R. (2018).
 <em>DiagrammeR: Graph/Network Visualization</em>.
 R package version 1.0.0.
[Â <a href="skew-bib_bib.html#pkg:diagrammer">bib</a>Â | 
<a href="https://CRAN.R-project.org/package=DiagrammeR">http</a>Â ]

</dd>


<dt>
[<a name="mertz1997ghostscript">Mertz, 1997</a>]
</dt>
<dd>
Mertz, T. (1997).
 <em>Ghostscript User Manual</em>.
 Springer-Verlag.
[Â <a href="skew-bib_bib.html#mertz1997ghostscript">bib</a>Â | 
<a href="https://books.google.co.nz/books?id=on61HAAACAAJ">http</a>Â ]

</dd>


<dt>
[<a name="vwline-pkg">Murrell, 2017</a>]
</dt>
<dd>
Murrell, P. (2017).
 <em>vwline: Draw variable-width lines</em>.
 R package version 0.1.
[Â <a href="skew-bib_bib.html#vwline-pkg">bib</a>Â ]

</dd>


<dt>
[<a name="pkg:gridgraphics">Murrell and Wen, 2018</a>]
</dt>
<dd>
Murrell, P. and Wen, Z. (2018).
 <em>gridGraphics: Redraw Base Graphics Using 'grid' Graphics</em>.
 R package version 0.3-0.
[Â <a href="skew-bib_bib.html#pkg:gridgraphics">bib</a>Â | 
<a href="https://CRAN.R-project.org/package=gridGraphics">http</a>Â ]

</dd>


<dt>
[<a name="cairo">Packard etÂ al., 2018</a>]
</dt>
<dd>
Packard, K., Worth, C., and Esfahbod, B. (2018).
 Cairo graphics library.
 <a href="https://www.cairographics.org/">https://www.cairographics.org/</a>.
 Accessed: 2018-08-30.
[Â <a href="skew-bib_bib.html#cairo">bib</a>Â ]

</dd>


<dt>
[<a name="pkg:grimport2">Potter, 2018</a>]
</dt>
<dd>
Potter, S. (2018).
 <em>grImport2: Importing 'SVG' Graphics</em>.
 R package version 0.1-5.
[Â <a href="skew-bib_bib.html#pkg:grimport2">bib</a>Â ]

</dd>


<dt>
[<a name="R">R Core Team, 2018</a>]
</dt>
<dd>
R Core Team (2018).
 <em>R: A Language and Environment for Statistical Computing</em>.
 R Foundation for Statistical Computing, Vienna, Austria.
[Â <a href="skew-bib_bib.html#R">bib</a>Â | 
<a href="https://www.R-project.org/">http</a>Â ]

</dd>


<dt>
[<a name="pkg:lattice">Sarkar, 2008</a>]
</dt>
<dd>
Sarkar, D. (2008).
 <em>Lattice: Multivariate Data Visualization with R</em>.
 Springer, New York.
 ISBN 978-0-387-75968-5.
[Â <a href="skew-bib_bib.html#pkg:lattice">bib</a>Â | 
<a href="http://lmdvr.r-forge.r-project.org">http</a>Â ]

</dd>


<dt>
[<a name="Schulze:18:SVG">Schulze etÂ al., 2018</a>]
</dt>
<dd>
Schulze, D., Bellamy-Royds, A., Lilley, C., Storey, D., Brinza, B., and
  Willigers, E. (2018).
 Scalable Vector Graphics (SVG) 2.
 Candidate recommendation, W3C.
 https://www.w3.org/TR/2018/CR-SVG2-20180807/.
[Â <a href="skew-bib_bib.html#Schulze:18:SVG">bib</a>Â ]

</dd>


<dt>
[<a name="pkg:tikz">Sharpsteen and Bracken, 2018</a>]
</dt>
<dd>
Sharpsteen, C. and Bracken, C. (2018).
 <em>tikzDevice: R Graphics Output in LaTeX Format</em>.
 R package version 0.12.
[Â <a href="skew-bib_bib.html#pkg:tikz">bib</a>Â | 
<a href="https://CRAN.R-project.org/package=tikzDevice">http</a>Â ]

</dd>


<dt>
[<a name="pkg:shape">Soetaert, 2018</a>]
</dt>
<dd>
Soetaert, K. (2018).
 <em>shape: Functions for Plotting Graphical Shapes, Colors</em>.
 R package version 1.4.4.
[Â <a href="skew-bib_bib.html#pkg:shape">bib</a>Â | 
<a href="https://CRAN.R-project.org/package=shape">http</a>Â ]

</dd>


<dt>
[<a name="tantau:2013">Tantau, 2013</a>]
</dt>
<dd>
Tantau, T. (2013).
 <em>The TikZ and PGF Packages</em>.
[Â <a href="skew-bib_bib.html#tantau:2013">bib</a>Â | 
<a href="http://sourceforge.net/projects/pgf/">http</a>Â ]

</dd>
</dl>
    <hr/>
    <p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img class="CC" alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"/></a><br/><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
    <script><![CDATA[
  var pdfcanvas = document.querySelectorAll("canvas.pdf");

  function renderPDF(i) {
    var canvas = pdfcanvas[i];
    var canvasid = canvas.id;
    console.log("loop " + canvasid);
    var loadingTask = pdfjsLib.getDocument(canvasid + '.pdf');
    loadingTask.promise.then(function(pdf) {
        pdf.getPage(1).then(function(page) {
            console.log("pdf" + canvasid);
            var scale = canvas.getAttribute("scale");
            if (!scale) {
                scale = 100/72;
            }
            var viewport = page.getViewport({ scale: scale, });
            var context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            var renderContext = {
                  canvasContext: context,
                  viewport: viewport
              };
            var renderTask = page.render(renderContext);
            renderTask.promise.then(function() {
                if (i + 1 < pdfcanvas.length) {
                    renderPDF(i + 1)
                }
            });   
         });
    });
  }

  function loadPDFs() {
    if (pdfcanvas.length > 0) {
        renderPDF(0);
    }
  }
  loadPDFs();
  ]]></script>
  </body>
</html>
